%!TEX root = FreeRtos ARM uController.tex
\subsection{Intertask Kommunikation}
In Projekten, in denen verschiedene Tasks parallel verarbeitet werden, ist es häufig erforderlich, dass diese Tasks die Möglichkeit besitzen Informationen untereinander auszutauschen. Sei es, weil ein Task Informationen produziert die ein anderer Task für die weitere Verarbeitung benötigt- oder auch, weil beide Tasks gemeinsame Ressourcen (bspw. Hardwareregister) verwenden und sichergestellt werden muss, dass die dort hinterlegten Daten jederzeit korrekt sind. Wie bei Desktop Betriebssystemen bietet auch FreeRTOS hier verschiedene Funktionen zur Interprozesskommunikation an. Zuerst sind hier die Queues zu nennen. Diese dienen dem klassischen Austausch von Informationen, indem Daten durch einen Task in die Queue hineingeschrieben werden und von einem zweiten Task gelesen werden. Meist bietet eine Queue die Option mehrere Datenpakete zu speichern. In FreeRTOS wird eine Queue mittels des folgenden Kommandos angelegt. 
\begin{lstlisting}[numbers = none]
xQueueCreate(uxQueueLength,uxItemSize)
\end{lstlisting}
Der Parameter uxQueueLength bezeichnet hierbei die Anzahl der maximal speicherbaren Elemente, uxItemSize die Größe eines einzelnen Datums. Daten werden in FreeRTOS immer in eine Queue hineinkopiert. 
Es werden keine expliziten Queues angeboten die Pointer speichern. Es ist jedoch möglich Pointer als Datum in einer Queue zu hinterlegen, wodurch keine Einschränkung durch die fehlende Implementierung einer expliziten Zeigerqueue entsteht. Die Entwickler müssen hierbei jedoch sicherstellen, dass der Inhalt im Pointerziel immer konsistent ist und keine Speicherzugriffsverletzungen stattfinden.
Um einen Überlauf der Queue zu verhindern, werden Tasks die in eine volle Queue hineinschreiben wollen in den Zustand Blocked versetzt. Ebenso werden Tasks behandelt, die versuchen Daten aus einer leeren Queue abzurufen. Um die Echtzeitfähigkeit der Tasks weiter zu gewährleisten, bieten die Funktionen xQueueSendToFront(), xQueueSendToBack() und xQueueReceive() einen Parameter xTicksToWait an, mit dem festgelegt werden kann, wie lange eine Task maximal auf eine Antwort wartet. Erfolgt innerhalb dieser Zeit keine Antwort, so erhält die Task eine der folgenden Rückantworten und wird fortgesetzt. 
\begin{lstlisting}[numbers = none]
errQUEUE_FULL oder errQueue_EMPTY
\end{lstlisting}
Sofern mehrere Tasks auf eine gemeinsame Queue zugreifen, so wird deren Zugriff im o.g. Fall zuerst nach Priorisierung der Task und danach durch Wartezeit gesteuert. Je nach Zustand der Queue erhält die Task mit der höchsten Priorität den Zugriff. Existieren zwei Tasks mit der gleichen Priorität, so darf die Task zugreifen, die schon länger auf einen Zugriff wartet.
Neben Queues werden von FreeRTOS Mailboxes angeboten. Diese verhalten sich grund\-sätz\-lich wie Queues, beinhalten jedoch nur ein Datenobjekt, welches nach dem Lesen auch nicht direkt gelöscht wird, sondern in der Mailbox verbleibt, bis es von einer datenerzeugenden Task überschrieben wird. Mailboxes sind vor allem in Szenarien interessant, in denen mehrere Tasks lesend auf ein erzeugtes Datum zugreifen sollen. Beispielsweise eine Task zur Verarbeitung und eine niedriger priorisierte Task zur Anzeige.
FreeRTOS bietet Semaphoren für die Behandlung von Interrupts an. Hierbei werden zwei Formen der Semaphoren unterschieden. Zum Einen die Binären Semaphoren, die unter Umständen Interrupts verlieren können, zum Anderen die Counting Semaphoren, die die Interrupts mitzählen. Auf diesem Weg kann eine Task auch im Nachhinein feststellen, wie oft ein Interrupt ausgeführt wurde.
Die nächste Gruppe der Funktionen zur Interprozesskommunikation sind die Mutexes, eine Sonderform der Semaphoren. Semaphoren werden detailliert im Abschnitt \ref{sec:Interrupt} beschrieben. Mutexes werden benutzt um Zugriff auf gemeinsam genutzte Ressourcen zu steuern. Wenn ein Task auf eine Ressource zugreifen will, so prüft er vorher, ob er den Mutex erhalten kann. Ist dies nicht der Fall (weil ein anderer Task den Mutex besitzt), so muss der Task warten bis der andere Task den Mutex zurück gibt. Zur Unterstützung von rekursiven Funktionen bietet FreeRTOS rekursive Mutexes an, die von einer Task mehrfach angefordert werden können. Im Rahmen von Echtzeitsystemen müssen jedoch zwei Risiken beim Einsatz von Mutexes berücksichtigt werden. Zum einen können Deadlocks entstehen. Hierbei versuchen zwei (oder mehr) Tasks zeitgleich auf zwei (oder mehr) Ressourcen zuzugreifen. Bei den Tasks gelingt es mindestens einen Mutex zu erhalten. In der Folge kann keiner der Tasks vollen Zugriff auf die Ressourcen erlangen und wartet jeweils auf den anderen. Der Deadlock kann nur aufgebrochen werden, indem einer der Tasks seine Mutexes zurück gibt und der andere diese erhalten kann. Durch die notwendigen Timeouts kann die Echt\-zeit\-fähig\-keit des Systems sichergestellt werden. Das andere Risiko besteht darin, dass eine niedrig priorisierte Task einen Mutex erhält und damit eine höher priorisierte Task von der Verwendung der Ressource ausschließt. FreeRTOS bietet hierzu eine Möglichkeit an, die niedrig priorisierte Task kurzzeitig auf die Priorität der hoch priorisierten Task zu setzen, so dass hier eine zeitnahe Abarbeitung stattfinden kann. Es kann jedoch auch hier zu Laufzeitproblemen kommen. Die Entwickler von FreeRTOS verwenden daher Wrapper-Funktionen, auch Gatekeeper genannt, die eine Kapselung der Ressourcen vornehmen und über Queues angesprochen werden. Auf diesem Weg kann auf den Einsatz von Mutexes weitestgehend verzichtet werden.
Die dritte und letzte Form der Intertaskkommunikation, die von FreeRTOS angeboten wird, ist die Task Notification. Sie ist die Variante mit dem geringsten Ressourcenaufwand, da anders als bei Queues und Mutexes keine Datenobjekte angelegt werden müssen. Durch das Aktivieren der Task Notifikation innerhalb der FreeRTOSConfig.h (Setzen von configUSE\_TASK\_NOTIFICATIONS auf 1) wird pro Task ein fester Speicherbereich reserviert, der für die Notification genutzt wird. Task Notifications werden direkt an die Zieltask gesendet. Es findet anders als bei Queues kein Zwischenspeichern der Information statt. Wenn eine Task eine andere Task benachrichtigt, so wird sie in den Zustand blockiert versetzt, bis der Notification Wert in den hierfür vorgesehen Speicherbereich geschrieben wurde. Darüber hinaus ist bei Notifications sichergestellt, dass die Informationen ausschließlich zwischen den beiden beteiligten Tasks ausgetauscht werden. Ein Zugriff eines dritten Tasks oder einer ISR (Interrupt Service Routine) auf diese Kommunikation ist ausgeschlossen.