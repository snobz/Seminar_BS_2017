%!TEX root = FreeRtos ARM uController.tex
\subsection{Intertask Kommunikation}
In Projekten, in denen verschiedene Tasks parallel verarbeitet werden, ist es häufig erforderlich, dass diese Tasks die Möglichkeit besitzen Informationen untereinander auszutauschen. Zum Einen kann ein Task Informationen produzieren, die ein anderer Task für die weitere Verarbeitung benötigt. Zum Anderen können beide Tasks gemeinsame Ressourcen (bspw. Hardwareregister oder Variablen) nutzen. Hierbei muss sichergestellt werden, dass die dort hinterlegten Daten jederzeit korrekt sind. FreeRTOS bietet hierfür verschiedene Funktionen zur Interprozesskommunikation an. Zuerst sind hier die Queues zu nennen. Diese dienen dem klassischen Austausch von Informationen, indem Daten durch einen Task in die Queue hineingeschrieben werden und von einem zweiten Task gelesen werden. Die Größe der Queue wird beim Aufruf der Erzeugerfunktion definiert. In FreeRTOS wird eine Queue mit folgender Funktion erstellt. 
\begin{lstlisting}[numbers = none]
xQueueCreate(uxQueueLength,uxItemSize)
\end{lstlisting}
Es werden keine expliziten Queues angeboten, die Pointer speichern. Es ist jedoch möglich Pointer als Datum in einer Queue zu hinterlegen. Um einen Überlauf der Queue zu verhindern, werden Tasks, die in eine volle Queue hineinschreiben wollen, in den Zustand Blocked versetzt. Ebenso werden Tasks behandelt, die versuchen Daten aus einer leeren Queue abzurufen. Um die Echtzeitfähigkeit der Tasks weiter zu gewährleisten, bieten die Funktionen xQueueSendToFront(), xQueueSendToBack() und xQueueReceive() einen Parameter xTicksToWait an. Mit xTicksToWait übergibt ein Task den Zeitwert, in dem der Task eine Antwort erwartet. Erfolgt innerhalb dieser Zeit keine Antwort, so wird der Task mittels Rückgabewert über diesen Timeout informiert.
Wenn mehrere Tasks auf eine gemeinsame Queue zugreifen, wird deren Zugriff im o.g. Fall zuerst nach Priorisierung des Tasks und danach durch Wartezeit gesteuert. Je nach Zustand der Queue erhält der Task mit der höchsten Priorität den Zugriff. Existieren zwei Tasks mit der gleichen Priorität, so darf der Task zugreifen, der schon länger auf einen Zugriff wartet.\newline
Neben Queues werden von FreeRTOS Mailboxen angeboten. Diese verhalten sich grund\-sätz\-lich wie Queues. Jedoch beinhalten sie nur ein Datenobjekt. Dieses wird nach dem Lesen nicht direkt gelöscht, sondern verbleibt in der Mailbox, bis es von einem datenerzeugenden Task überschrieben wird. Mailboxen sind vor allem in Szenarien interessant, in denen mehrere Tasks lesend auf ein erzeugtes Datum zugreifen sollen. Beispielsweise greift ein Task zur Verarbeitung und ein niedriger priorisierter Task zur Anzeige auf die Mailbox zu.\newline
FreeRTOS bietet außerdem Semaphore an. Üblicherweise werden diese für die Behandlung von Interrupts verwendet. Semaphore werden im Rahmen der Interprozesskommunikation meist zur Synchronisierung der Tasks angewendet. Hierzu wird durch einen Task der Semaphor angefordert, durch den zweiten Task der Semaphor vergleichbar einem Interrupt gesetzt. Semaphore werden detailliert im Abschnitt \ref{sec:Interrupt} beschrieben.\newline
Die nächste Gruppe der Funktionen zur Interprozesskommunikation sind die Mutexe. Diese bilden eine Sonderform der Semaphore.  Mutexe werden benutzt um Zugriffe auf gemeinsam genutzte Ressourcen zu steuern. Wenn ein Task auf eine Ressource zugreifen will, so prüft er vorher, ob er den Mutex erhalten kann. Ist dies nicht der Fall (weil ein anderer Task den Mutex besitzt), so muss der Task warten bis der andere Task den Mutex zurück gibt. Zur Unterstützung von rekursiven Funktionen bietet FreeRTOS rekursive Mutexe an, die von einer Task mehrfach angefordert werden können. Im Rahmen von Echtzeitsystemen müssen jedoch zwei Risiken beim Einsatz von Mutexen berücksichtigt werden. Es besteht ein Risiko darin, dass Deadlocks entstehen. Hierbei versuchen zwei (oder mehr) Tasks zeitgleich auf zwei (oder mehr) Ressourcen zu zugreifen. Beiden Tasks gelingt es mindestens einen Mutex zu erhalten. In der Folge kann keiner der Tasks vollen Zugriff auf die Ressourcen erlangen und wartet jeweils auf den anderen. Der Deadlock kann nur aufgebrochen werden, indem einer der Tasks seine Mutexe zurück gibt und der andere diese erhalten kann. Durch die notwendigen Timeouts kann die Echt\-zeit\-fähig\-keit des Systems sichergestellt werden. Das andere Risiko besteht darin, dass eine niedrig priorisierte Task einen Mutex erhält und damit eine höher priorisierte Task von der Verwendung der Ressource ausschließt. FreeRTOS bietet hierzu eine Möglichkeit an, die niedrig priorisierte Task kurzzeitig auf die Priorität der hoch priorisierten Task zu setzen, so dass hier eine zeitnahe Abarbeitung stattfinden kann. Es kann jedoch auch hier zu Laufzeitproblemen kommen. Die Entwickler von FreeRTOS verwenden daher Wrapper-Funktionen, auch Gatekeeper genannt. Diese nehmen eine Kapselung der Ressourcen vor und werden über Queues angesprochen. Auf diesem Weg kann auf den Einsatz von Mutexen weitestgehend verzichtet werden.
Die dritte und letzte Form der Intertaskkommunikation, die von FreeRTOS angeboten wird, ist die Task Notification. Sie ist die Variante mit dem geringsten Ressourcenaufwand, da anders als bei Queues und Mutexes keine Datenobjekte angelegt werden müssen. Durch das Aktivieren der Task Notifikation innerhalb der FreeRTOSConfig.h (Setzen von configUSE\_TASK\_NOTIFICATIONS auf 1) wird pro Task ein fester Speicherbereich reserviert, der für die Notification genutzt wird. Task Notifications werden direkt an die Zieltask gesendet. Es findet, anders als bei Queues, kein Zwischenspeichern der Information statt. Wenn ein Task einen anderen Task benachrichtigt, wird er in den Zustand blockiert versetzt, bis der Notification Wert in den hierfür vorgesehen Speicherbereich geschrieben wurde. Darüber hinaus ist bei Notifications sichergestellt, dass die Informationen ausschließlich zwischen den beiden beteiligten Tasks ausgetauscht werden. Ein Zugriff eines dritten Tasks oder einer ISR (Interrupt Service Routine) auf diese Kommunikation ist ausgeschlossen.
