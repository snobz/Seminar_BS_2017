%!TEX root = FreeRtos ARM uController.tex
\subsection{Intertask Kommunikation}
%Michael: Ich habe in diesen Abschnitten nichts verändert, nur ein paar Kommentare. Vielleicht sollten wir noch etwas an Beispielen einbringen, wie von Frau Ma empfohlen hat. Zur Zeit ist es ne ziemliche wall of text :) 
In Projekten, in denen verschiedene Tasks parallel verarbeitet werden, ist es häufig erforderlich, dass diese Tasks die Möglichkeit besitzen Informationen untereinander auszutauschen. Zum Einen kann ein Task Informationen produzieren, die ein anderer Task für die weitere Verarbeitung benötigt. Zum Anderen können beide Tasks gemeinsame Ressourcen (z.B. Hardwareregister oder Variablen) nutzen. Hierbei muss sichergestellt werden, dass die dort hinterlegten Daten jederzeit korrekt sind. FreeRTOS bietet hierfür verschiedene Funktionen zur Interprozesskommunikation an.\newline Zuerst sind hier die Queues zu nennen. Diese dienen dem klassischen Austausch von Informationen, indem Daten durch einen Task in die Queue hineingeschrieben werden und von einem zweiten Task gelesen werden. Die Größe der Queue wird beim Aufruf der Erzeugerfunktion definiert. In FreeRTOS wird eine Queue mit folgender Funktion erstellt: 
\begin{lstlisting}[numbers = none]
xQueueCreate(uxQueueLength,uxItemSize)
\end{lstlisting}
Es werden keine expliziten Queues angeboten, die Pointer speichern. Es ist jedoch möglich Pointer als Datum in einer Queue zu hinterlegen. Um einen Überlauf der Queue zu verhindern, werden Tasks, die in eine volle Queue hineinschreiben wollen, in den Zustand Blocked versetzt. Ebenso werden Tasks behandelt, die versuchen Daten aus einer leeren Queue abzurufen. Um die Echtzeitfähigkeit der Tasks weiter zu gewährleisten, bieten die Funktionen xQueueSendToFront(), xQueueSendToBack() und xQueueReceive() einen Parameter xTicksToWait an. Mit xTicksToWait übergibt ein Task den Zeitwert, in dem der Task eine Antwort erwartet. Erfolgt innerhalb dieser Zeit keine Antwort, so wird der Task mittels Rückgabewert über diesen Timeout informiert.
Wenn mehrere Tasks auf eine gemeinsame Queue zugreifen, wird deren Zugriff im o.g. Fall zuerst nach Priorisierung des Tasks und danach durch Wartezeit gesteuert. Je nach Zustand der Queue erhält der Task mit der höchsten Priorität den Zugriff. Existieren zwei Tasks mit der gleichen Priorität, so darf der Task zugreifen, der schon länger auf einen Zugriff wartet.\newline
Neben Queues werden von FreeRTOS Mailboxen angeboten. Diese verhalten sich grund\-sätz\-lich wie Queues, jedoch beinhalten sie nur ein Datenobjekt. Dieses wird nach dem Lesen nicht direkt gelöscht, sondern verbleibt in der Mailbox, bis es von einem datenerzeugenden Task über\-schrie\-ben wird. Mailboxen sind vor allem in Szenarien interessant, in denen mehrere Tasks lesend auf ein erzeugtes Datum zugreifen sollen. Beispielsweise greift ein Task zur Verarbeitung und ein niedriger priorisierter Task zur Anzeige auf die Mailbox zu.
%Ich konnte gar nichts zu Mailboxes finden in FreeRTOS, wo hast du das gefunden. Das einzige was ich finden konnte, war wie man Mailboxes durch Notify implementiern kann.http://www.freertos.org/RTOS_Task_Notification_As_Mailbox.html
\newline
FreeRTOS bietet außerdem Semaphore an. Üblicherweise werden diese für die Behandlung von Interrupts verwendet. Semaphore werden im Rahmen der Interprozesskommunikation meist zur Synchronisierung der Tasks angewendet. 
%Michael :Bei Semaphoren geht es doch eigentlich nicht nur um Interrupts, sondern um die Synchronisierung von Zugriffen auf gemeinsame Ressourcen? Dabei ist doch eigentlich egal ob das ganze aus einer ISR oder aus einer Task stattfindet. Der einzige unterschied ist, dass man eine andere Funktion aufrufen muss _fromISR(). Könnte mir vorstellen, dass sowas von den Profs gefragt wird.
Hierzu wird durch einen Task der Semaphor angefordert und durch den zweiten Task der Semaphor vergleichbar einem Interrupt gesetzt. Semaphore werden detailliert im Abschnitt \ref{sec:Interrupt} beschrieben.
%Semaphor vergleichbar einem Interrupt gesetzt. 
%Michael: Wie meinst du das?  Ein Interrupt wird doch durch die Hardware gesetzt, das ist doch ganz was anderes.
\newline
Die nächste Gruppe der Funktionen zur Interprozesskommunikation sind die Mutexe. Diese bilden eine Sonderform der Semaphore. 
%Hier noch ein Auszug der FreeRTOS Website, vielleicht auch noch hilfreich.
%"--Binary semaphores and mutexes are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.--see http://www.freertos.org/Embedded-RTOS-Binary-Semaphores.html.
Mutexe werden benutzt um Zugriffe auf gemeinsam genutzte Ressourcen zu steuern. Wenn ein Task auf eine Ressource zugreifen will, so prüft er vorher, ob er den Mutex erhalten kann. Ist dies nicht der Fall, weil ein anderer Task den Mutex besitzt, so muss der Task warten bis der andere Task den Mutex zurück gibt. Zur Unterstützung von rekursiven Funktionen bietet FreeRTOS rekursive Mutexe an, die von einem Task mehrfach angefordert werden können. 
%Grafik Deadlock
%Ist das wirklich interessant ? Glaube das rekursive Mutexe 99,9 % der Fälle nicht eingesetzt werden. 
Im Rahmen von Echtzeitsystemen müssen jedoch zwei Risiken beim Einsatz von Mutexen berücksichtigt werden. Es besteht ein Risiko darin, dass Deadlocks entstehen. Hierbei versuchen zwei, oder mehr Tasks zeitgleich auf zwei, oder mehr Ressourcen zuzugreifen. Beiden Tasks gelingt es mindestens einen Mutex zu erhalten. In Folge kann keiner der Tasks vollen Zugriff auf die Ressourcen erlangen und wartet jeweils auf den anderen. Der Deadlock kann nur aufgebrochen werden, indem einer der Tasks seine Mutexe zurück gibt und der andere diese erhalten kann. 
Durch die notwendigen Timeouts kann die Echt\-zeit\-fähig\-keit des Systems sichergestellt werden. Das andere Risiko besteht darin, dass ein niedrig priorisierter Task einen Mutex erhält und damit einem höher priorisierten Task von der Verwendung der Ressource ausschließt. FreeRTOS bietet hierzu eine Möglichkeit den niedrig priorisierten Task kurzzeitig auf die Priorität des hoch priorisierten Tasks zu setzen, sodass eine zeitnahe Abarbeitung stattfinden kann. Es kann jedoch auch hier zu Laufzeitproblemen kommen. 
%Michael: Meinst du wir sollten erklären wie ein Deadlock und Starvation funktioniert und wie man diese auflösen kann ? Reicht es nicht wenn wir darauf hinweisen ? Das ist ja eigentlich ein allgemeines Problem und nicht RTOS spezifisch. Stattdessen könnte man doch lieber ein paar Beispiele zu den Funktionalitäten bringen.  
Die Entwickler von FreeRTOS verwenden daher Wrapper-Funktionen, auch Gatekeeper genannt. Diese nehmen eine Kapselung der Ressourcen vor und werden über Queues angesprochen. Auf diesem Weg kann auf den Einsatz von Mutexen weitestgehend verzichtet werden.
%Grafik für Wrapper-Funktion
%Michael: Habe noch nie von Gatekeepern (außer bei Thor :P ) gehört und wie helfen sie, dass wir nicht ganz klar.
Die dritte Form der Intertaskkommunikation, die von FreeRTOS angeboten wird, ist die Task Notification. Sie ist die Variante mit dem geringsten Ressourcenaufwand, da anders als bei Queues und Mutexes keine Datenobjekte angelegt werden müssen. Durch das Aktivieren der Task Notifikation innerhalb der FreeRTOSConfig.h (Setzen von configUSE\_TASK\_NOTIFICATIONS auf 1) wird pro Task ein fester Speicherbereich reserviert, der für die Notification genutzt wird. Task Notifications werden direkt an den Zieltask gesendet. Es findet, anders als bei Queues, kein Zwischenspeichern der Information statt. Wenn ein Task einen anderen Task benachrichtigt, wird er in den Zustand Blockiert versetzt, bis der Notification Wert in den hierfür vorgesehen Speicherbereich geschrieben wurde. Darüber hinaus ist bei Notifications sichergestellt, dass die Informationen ausschließlich zwischen den beiden beteiligten Tasks ausgetauscht werden. Ein Zugriff eines dritten Tasks oder einer ISR (Interrupt Service Routine) auf diese Kommunikation ist ausgeschlossen.
