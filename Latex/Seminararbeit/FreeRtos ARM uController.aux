\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\catcode `"\active 
\citation{RTOSRevealed}
\citation{RTOSRevealed}
\select@language{ngerman}
\@writefile{toc}{\select@language{ngerman}}
\@writefile{lof}{\select@language{ngerman}}
\@writefile{lot}{\select@language{ngerman}}
\@writefile{toc}{\contentsline {section}{\numberline {1}Grundlagen Echtzeitsysteme}{1}{section.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Echtzeitsysteme und Echtzeitbetriebssysteme}{1}{subsection.1.1}}
\newlabel{sec:Echtzeitsysteme}{{1.1}{1}{Echtzeitsysteme und Echtzeitbetriebssysteme}{subsection.1.1}{}}
\newlabel{sec:Echtzeitsysteme@cref}{{[subsection][1][1]1.1}{1}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces \IeC {\"U}bersicht Programmabl\IeC {\"a}ufe in embedded Anwendungen. Unterscheidung von zwei Hauptkategorien: Schleifen-gesteurte Anwendungen und Event-gesteurte Anwendungen. Bild-Quelle~\citeA {RTOSRevealed}}}{1}{figure.1}}
\newlabel{fig:Programmablauf}{{1}{1}{Übersicht Programmabläufe in embedded Anwendungen. Unterscheidung von zwei Hauptkategorien: Schleifen-gesteurte Anwendungen und Event-gesteurte Anwendungen. Bild-Quelle~\protect \citeA {RTOSRevealed}}{figure.1}{}}
\newlabel{fig:Programmablauf@cref}{{[figure][1][]1}{1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}FreeRTOS}{2}{section.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Geschichte}{2}{subsection.2.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Entwicklungsumgebung}{2}{subsection.2.2}}
\newlabel{ref:Entwicklungsumgebung}{{2.2}{2}{Entwicklungsumgebung}{subsection.2.2}{}}
\newlabel{ref:Entwicklungsumgebung@cref}{{[subsection][2][2]2.2}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Zielsysteme STM32F4 (ARM Cortex M4)}{2}{subsection.2.3}}
\newlabel{sec:Zielsysteme}{{2.3}{2}{Zielsysteme STM32F4 (ARM Cortex M4)}{subsection.2.3}{}}
\newlabel{sec:Zielsysteme@cref}{{[subsection][3][2]2.3}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Aufbau der zur Verf\IeC {\"u}gung stehenden STM Bibliotheken }}{2}{figure.2}}
\newlabel{fig:HAL}{{2}{2}{Aufbau der zur Verfügung stehenden STM Bibliotheken}{figure.2}{}}
\newlabel{fig:HAL@cref}{{[figure][2][]2}{2}}
\@writefile{lot}{\contentsline {table}{\numberline {1}{\ignorespaces Beispiele von Echtzeitsystemen und deren Auswirkung beim \IeC {\"u}ber- oder unterschreiten der Anforderungsgrenzen}}{3}{table.1}}
\newlabel{tab:BeispieleEchtzeitsystem}{{1}{3}{Beispiele von Echtzeitsystemen und deren Auswirkung beim über- oder unterschreiten der Anforderungsgrenzen}{table.1}{}}
\newlabel{tab:BeispieleEchtzeitsystem@cref}{{[table][1][]1}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Einrichten und Konfiguration}{3}{subsection.2.4}}
\newlabel{sec:Einrichtung und Konfiguration}{{2.4}{3}{Einrichten und Konfiguration}{subsection.2.4}{}}
\newlabel{sec:Einrichtung und Konfiguration@cref}{{[subsection][4][2]2.4}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Erstellung eines Basisprojekts f\IeC {\"u}r den STM32F4 durch das GNU ARM Plugin. Ein Wizzard Konfigurator f\IeC {\"u}hrt den Anwender durch alle n\IeC {\"o}tigen Einstellungen. Nach Abschluss erh\IeC {\"a}lt man ein fertiges C / C++ ARM Projekt welches passend zum Zielsystem konfiguriert ist.}}{3}{figure.3}}
\newlabel{fig:NewProj}{{3}{3}{Erstellung eines Basisprojekts für den STM32F4 durch das GNU ARM Plugin. Ein Wizzard Konfigurator führt den Anwender durch alle nötigen Einstellungen. Nach Abschluss erhält man ein fertiges C / C++ ARM Projekt welches passend zum Zielsystem konfiguriert ist}{figure.3}{}}
\newlabel{fig:NewProj@cref}{{[figure][3][]3}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces ARM embedded Anwendungen setzten auf unterschiedliche Abstraktionsschichten auf. Die untersten beiden Abstraktionsschichten sind CMSIS, welches Funktionen f\IeC {\"u}r ARM Devices bereitstellt und die HAL des uController Herstellers. CMSIS steht f\IeC {\"u}r alle ARM Systeme zur Verf\IeC {\"u}gung, wohingegen die HAL uController spezifisch ist. }}{3}{figure.4}}
\newlabel{fig:CMSIS}{{4}{3}{ARM embedded Anwendungen setzten auf unterschiedliche Abstraktionsschichten auf. Die untersten beiden Abstraktionsschichten sind CMSIS, welches Funktionen für ARM Devices bereitstellt und die HAL des uController Herstellers. CMSIS steht für alle ARM Systeme zur Verfügung, wohingegen die HAL uController spezifisch ist}{figure.4}{}}
\newlabel{fig:CMSIS@cref}{{[figure][4][]4}{3}}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\citation{FreeRtosAdvanced}
\citation{RTOSRevealed}
\citation{RTOSRevealed}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Die Basiskonfiguration die durch das GNU ARM Plugin zur Verf\IeC {\"u}gung gestellt werden, besteht aus den Verzeichnissen: Startup, Config und HAL. Startup beinhaltet alle Files zum Starten der Hardware und die main. Im Config Verzeichnisse befinden sich alle Files zur Konfiguration des uControllers und die FreeRTOS Config. Die HAL und CMSIS sind die Grundlage des Systems und werden ebenfalls durch das GNU ARM Plugin eingef\IeC {\"u}gt. FreeRTOS wird danach manuell dem Projekt hinzugef\IeC {\"u}gt.}}{4}{figure.5}}
\newlabel{fig:SourceTree}{{5}{4}{Die Basiskonfiguration die durch das GNU ARM Plugin zur Verfügung gestellt werden, besteht aus den Verzeichnissen: Startup, Config und HAL. Startup beinhaltet alle Files zum Starten der Hardware und die main. Im Config Verzeichnisse befinden sich alle Files zur Konfiguration des uControllers und die FreeRTOS Config. Die HAL und CMSIS sind die Grundlage des Systems und werden ebenfalls durch das GNU ARM Plugin eingefügt. FreeRTOS wird danach manuell dem Projekt hinzugefügt}{figure.5}{}}
\newlabel{fig:SourceTree@cref}{{[figure][5][]5}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.5}Memory Allocation}{4}{subsection.2.5}}
\newlabel{lst:vPortMalloc1}{{2.5}{4}{}{lstlisting.-1}{}}
\newlabel{lst:vPortMalloc1@cref}{{[subsection][5][2]2.5}{4}}
\newlabel{lst:vPortFree1}{{2.5}{4}{}{lstlisting.-2}{}}
\newlabel{lst:vPortFree1@cref}{{[subsection][5][2]2.5}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Einbindung des Speicheralgorithmus Heap1 in Eclipse CDT. Die Algortihmen Heap2 bis Heap5 sind vom Build ausgeschlossen}}{4}{figure.6}}
\newlabel{fig:HeapsEclipse}{{6}{4}{Einbindung des Speicheralgorithmus Heap1 in Eclipse CDT. Die Algortihmen Heap2 bis Heap5 sind vom Build ausgeschlossen}{figure.6}{}}
\newlabel{fig:HeapsEclipse@cref}{{[figure][6][]6}{4}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.5.1}FreeRTOS Algorithmen zur Speicherverwaltung}{4}{subsubsection.2.5.1}}
\newlabel{lst:malloc2}{{1}{5}{FreeRTOS Source von pvPortMalloc() aus Heap1.c. Zuerst wird sichergestellt das die Startspeicheradresse dem byte-Alignment des $\mu $\-Pro\-zesso\-rs entspricht. Der STM32F4 ist ein 32Bit $\mu $\-Pro\-zesso\-r und hat ein byte-Alignment von 4, so dass die Startadresse immer eine Potenz von 4 sein muss. Danach wird der Scheduler deaktiviert und geprüft ob genug Speicher zur Verfügung steht. Abschließend wird der Speicher im ucHeap reserviert}{lstlisting.1}{}}
\newlabel{lst:malloc2@cref}{{[lstlisting][1][]1}{5}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {1}FreeRTOS Source von pvPortMalloc() aus Heap1.c. Zuerst wird sichergestellt das die Startspeicheradresse dem byte-Alignment des $\mu $\discretionary {-}{}{}Pro\discretionary {-}{}{}zesso\discretionary {-}{}{}rs entspricht. Der STM32F4 ist ein 32Bit $\mu $\discretionary {-}{}{}Pro\discretionary {-}{}{}zesso\discretionary {-}{}{}r und hat ein byte-Alignment von 4, so dass die Startadresse immer eine Potenz von 4 sein muss. Danach wird der Scheduler deaktiviert und gepr\IeC {\"u}ft ob genug Speicher zur Verf\IeC {\"u}gung steht. Abschlie\IeC {\ss }end wird der Speicher im ucHeap reserviert.}{5}{lstlisting.1}}
\newlabel{lst:free2}{{2}{5}{FreeRTOS Source von vPortFree() aus Heap1.c . Da eine Speicherfreigabe in Heap1 nicht vorgesehen ist, ist diese Funktion leer}{lstlisting.2}{}}
\newlabel{lst:free2@cref}{{[lstlisting][2][]2}{5}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {2}FreeRTOS Source von vPortFree() aus Heap1.c . Da eine Speicherfreigabe in Heap1 nicht vorgesehen ist, ist diese Funktion leer.}{5}{lstlisting.2}}
\newlabel{lst:xTaskCreate}{{3}{5}{FreeRTOS Source von xTaskCreate() aus Task.c. Jede Task bestitzt einen Stack und einen Task Control Block, beide werden beim Aufruf von xTaskCreate (Zeile 5 und Zeile 11) erstellt}{lstlisting.3}{}}
\newlabel{lst:xTaskCreate@cref}{{[lstlisting][3][]3}{5}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {3}FreeRTOS Source von xTaskCreate() aus Task.c. Jede Task bestitzt einen Stack und einen Task Control Block, beide werden beim Aufruf von xTaskCreate (Zeile 5 und Zeile 11) erstellt.}{5}{lstlisting.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Task und Kernel teilen sich in FreeRTOS einen gemeinsamen Adressraum. Dies stellt eine potentielle Fehlerquelle dar. Bild-Quelle~\citeA {RTOSRevealed}}}{5}{figure.7}}
\newlabel{fig:AddressSpace}{{7}{5}{Task und Kernel teilen sich in FreeRTOS einen gemeinsamen Adressraum. Dies stellt eine potentielle Fehlerquelle dar. Bild-Quelle~\protect \citeA {RTOSRevealed}}{figure.7}{}}
\newlabel{fig:AddressSpace@cref}{{[figure][7][]7}{5}}
\citation{RTOSRevealed}
\citation{RTOSRevealed}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\newlabel{lst:ucHeap}{{2.5.1}{6}{}{lstlisting.-3}{}}
\newlabel{lst:ucHeap@cref}{{[subsubsection][1][2,5]2.5.1}{6}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Beispiel Speicherbelegung nach drei Instanziierung von Tasks durch die Erzeugerfunktion xTaskCreate() unter Verwendung des Speicheralgorithmus Heap1. Bild-Quelle~\citeA {MasteringFreeRtos}}}{6}{figure.8}}
\newlabel{fig:Heap1}{{8}{6}{Beispiel Speicherbelegung nach drei Instanziierung von Tasks durch die Erzeugerfunktion xTaskCreate() unter Verwendung des Speicheralgorithmus Heap1. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.8}{}}
\newlabel{fig:Heap1@cref}{{[figure][8][]8}{6}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.5.2}Memory Protection}{6}{subsubsection.2.5.2}}
\newlabel{sec:Memory Protection}{{2.5.2}{6}{Memory Protection}{subsubsection.2.5.2}{}}
\newlabel{sec:Memory Protection@cref}{{[subsubsection][2][2,5]2.5.2}{6}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.5.3}Static Memory Allocation}{6}{subsubsection.2.5.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Zugriffsrechte f\IeC {\"u}r Restricted Task wird durch den RTOS Kernel in der MPU konfiguriert. Der Speicherzugriff wir automatisch durch MPU/ MMU \IeC {\"u}berpr\IeC {\"u}ft und im Fehlerfall an den Kernel gemeldet. Bild-Quelle~\citeA {RTOSRevealed}}}{6}{figure.9}}
\newlabel{fig:AddressSpaceMMU}{{9}{6}{Zugriffsrechte für Restricted Task wird durch den RTOS Kernel in der MPU konfiguriert. Der Speicherzugriff wir automatisch durch MPU/ MMU überprüft und im Fehlerfall an den Kernel gemeldet. Bild-Quelle~\protect \citeA {RTOSRevealed}}{figure.9}{}}
\newlabel{fig:AddressSpaceMMU@cref}{{[figure][9][]9}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.6}Scheduling}{6}{subsection.2.6}}
\newlabel{Scheduling}{{2.6}{6}{Scheduling}{subsection.2.6}{}}
\newlabel{Scheduling@cref}{{[subsection][6][2]2.6}{6}}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\citation{9783827373427}
\citation{9783827373427}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Der Kontextwechsel einer Task findet mitten in der Ausf\IeC {\"u}hrung statt. Alle Register die f\IeC {\"u}r die weitere Ausf\IeC {\"u}hrung ben\IeC {\"o}tigt werden, werden durch den Scheduler gesichert. Bild-Quelle~\citeA {MasteringFreeRtos} }}{7}{figure.10}}
\newlabel{fig:ContextSwitch}{{10}{7}{Der Kontextwechsel einer Task findet mitten in der Ausführung statt. Alle Register die für die weitere Ausführung benötigt werden, werden durch den Scheduler gesichert. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.10}{}}
\newlabel{fig:ContextSwitch@cref}{{[figure][10][]10}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces \IeC {\"U}bersicht aller Task Zustandstransitionen in FreeRTOS. Der Zustandswechsel findet entweder durch den Aufruf einer FreeRTOS API Funktion statt3oder aber durch Event z.B. Interrupts, Timer-Events. Der Wechsel in den Zustand Running wird durch den Scheduler bestimmt und ist durch den Schedulingalgorithmus definiert. Bild-Quelle~\citeA {MasteringFreeRtos}}}{7}{figure.11}}
\newlabel{fig:TaskStates}{{11}{7}{Übersicht aller Task Zustandstransitionen in FreeRTOS. Der Zustandswechsel findet entweder durch den Aufruf einer FreeRTOS API Funktion statt3oder aber durch Event z.B. Interrupts, Timer-Events. Der Wechsel in den Zustand Running wird durch den Scheduler bestimmt und ist durch den Schedulingalgorithmus definiert. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.11}{}}
\newlabel{fig:TaskStates@cref}{{[figure][11][]11}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces Aufbau der Priorit\IeC {\"a}tenliste nach Round Robin in FreeRTOS. Alle aufgef\IeC {\"u}hrten Task sind bereit zur Ausf\IeC {\"u}hrung. Task A wird aktuell durch den Scheduler ausgef\IeC {\"u}hrt. Nach dem Ablauf des Zeitquantums, wird A hinter B einsortiert. Die Maximale Priorit\IeC {\"a}t wird durch configMaxPrio bestimmt. Die Idle Task wird automatisch durch den Kernel erzeugt und hat immer die niedrigste Priorit\IeC {\"a}t. }}{7}{figure.12}}
\newlabel{fig:PrioList1}{{12}{7}{Aufbau der Prioritätenliste nach Round Robin in FreeRTOS. Alle aufgeführten Task sind bereit zur Ausführung. Task A wird aktuell durch den Scheduler ausgeführt. Nach dem Ablauf des Zeitquantums, wird A hinter B einsortiert. Die Maximale Priorität wird durch configMaxPrio bestimmt. Die Idle Task wird automatisch durch den Kernel erzeugt und hat immer die niedrigste Priorität}{figure.12}{}}
\newlabel{fig:PrioList1@cref}{{[figure][12][]12}{7}}
\newlabel{lst:nextTask}{{4}{7}{FreeRTOS Source zur Priroty Task Selection aus Task.c. Alle lauffähigen Task werden in einem Array vewaltet pxReadyTaskLists. Die Listen verwalten sich durch Referenz-Pointer in den TCBs der einzelnen Tasks}{lstlisting.4}{}}
\newlabel{lst:nextTask@cref}{{[lstlisting][4][]4}{7}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {4}FreeRTOS Source zur Priroty Task Selection aus Task.c. Alle lauff\IeC {\"a}higen Task werden in einem Array vewaltet pxReadyTaskLists. Die Listen verwalten sich durch Referenz-Pointer in den TCBs der einzelnen Tasks}{7}{lstlisting.4}}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\@writefile{lof}{\contentsline {figure}{\numberline {13}{\ignorespaces Im Co-operative Modus wird der Prozessor von einer Task erst abgegeben, wenn diese explizit taskYield() aufruft. Selbst wenn eine Task mit h\IeC {\"o}hrer Priorit\IeC {\"a}t in den Ready Zustand wechselt, l\IeC {\"a}uft die Task mit niedrigerer Priorit\IeC {\"a}t weiter. Im Gegensatz dazu steht das Pre-Emptive Scheduling (hier mit Time-Slicing), es unterbricht die laufende Task mit niedriger Priorit\IeC {\"a}t sofort, sobald eine Task mit h\IeC {\"o}herer Priorit\IeC {\"a}t Ready ist. Bild-Quelle~\citeA {MasteringFreeRtos}}}{8}{figure.13}}
\newlabel{fig:PreVSCo}{{13}{8}{Im Co-operative Modus wird der Prozessor von einer Task erst abgegeben, wenn diese explizit taskYield() aufruft. Selbst wenn eine Task mit höhrer Priorität in den Ready Zustand wechselt, läuft die Task mit niedrigerer Priorität weiter. Im Gegensatz dazu steht das Pre-Emptive Scheduling (hier mit Time-Slicing), es unterbricht die laufende Task mit niedriger Priorität sofort, sobald eine Task mit höherer Priorität Ready ist. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.13}{}}
\newlabel{fig:PreVSCo@cref}{{[figure][13][]13}{8}}
\newlabel{lst:SysTickS}{{5}{8}{FreeRTOS Source des SysTickHandlers aus Task.c. Der SysTickHandler verwaltet den TickCount. Der TickCount dient allen Timingfunktionen des RTOS Kernels als Zeitreferenz. Des Weiteren wird bei aktivem Time Slicing überprüft ob ein Kontextwechsel nötig ist. Der Kontext wechsel wir dann ggf. durch den PendSVHandler durchgeführt}{lstlisting.5}{}}
\newlabel{lst:SysTickS@cref}{{[lstlisting][5][]5}{8}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {5}FreeRTOS Source des SysTickHandlers aus Task.c. Der SysTickHandler verwaltet den TickCount. Der TickCount dient allen Timingfunktionen des RTOS Kernels als Zeitreferenz. Des Weiteren wird bei aktivem Time Slicing \IeC {\"u}berpr\IeC {\"u}ft ob ein Kontextwechsel n\IeC {\"o}tig ist. Der Kontext wechsel wir dann ggf. durch den PendSVHandler durchgef\IeC {\"u}hrt.}{8}{lstlisting.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.7}Intertask Kommunikation}{8}{subsection.2.7}}
\@writefile{lof}{\contentsline {figure}{\numberline {14}{\ignorespaces Beispielhafter Ablauf eines SysTickInterrupts.(1) keine User Task ist ready, die Idle Task ist aktiv. (2) SysTickInterrupt. (3) SysTickHandler wird aufgerufen. (4) vControlTask ist ready und ein Kontext wechsel wird durchgef\IeC {\"u}hrt. vControlTask hat hier die gleiche Priorit\IeC {\"a}t wie die IdleTask. (5)vControlTask wird ausgef\IeC {\"u}hrt. Bild-Quelle~\citeA {MasteringFreeRtos}}}{8}{figure.14}}
\newlabel{fig:SysTick}{{14}{8}{Beispielhafter Ablauf eines SysTickInterrupts.(1) keine User Task ist ready, die Idle Task ist aktiv. (2) SysTickInterrupt. (3) SysTickHandler wird aufgerufen. (4) vControlTask ist ready und ein Kontext wechsel wird durchgeführt. vControlTask hat hier die gleiche Priorität wie die IdleTask. (5)vControlTask wird ausgeführt. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.14}{}}
\newlabel{fig:SysTick@cref}{{[figure][14][]14}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {15}{\ignorespaces Durch das Zeitschlitzverfahren wechseln sich Task1 und Idle Task bei jedem SysTick Interrupt ab, da beide die gleiche Priorit\IeC {\"a}t haben. Bei T6 ist Task 1 bereit und verdr\IeC {\"a}ngt (preempt) aufgrund ihrer h\IeC {\"o}heren Priorit\IeC {\"a}t Task2. Nachdem Task 1 blockiert, wird Task 2 fortgef\IeC {\"u}hrt. Bild-Quelle~\citeA {MasteringFreeRtos}}}{8}{figure.15}}
\newlabel{fig:timeslice}{{15}{8}{Durch das Zeitschlitzverfahren wechseln sich Task1 und Idle Task bei jedem SysTick Interrupt ab, da beide die gleiche Priorität haben. Bei T6 ist Task 1 bereit und verdrängt (preempt) aufgrund ihrer höheren Priorität Task2. Nachdem Task 1 blockiert, wird Task 2 fortgeführt. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.15}{}}
\newlabel{fig:timeslice@cref}{{[figure][15][]15}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.8}Interrupt Handling}{9}{subsection.2.8}}
\newlabel{sec:Interrupt}{{2.8}{9}{Interrupt Handling}{subsection.2.8}{}}
\newlabel{sec:Interrupt@cref}{{[subsection][8][2]2.8}{9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.9}Low Power Modes auf Stm32F4}{10}{subsection.2.9}}
\newlabel{sec:Low Power Modes}{{2.9}{10}{Low Power Modes auf Stm32F4}{subsection.2.9}{}}
\newlabel{sec:Low Power Modes@cref}{{[subsection][9][2]2.9}{10}}
\@writefile{lof}{\contentsline {figure}{\numberline {16}{\ignorespaces Der STM32F4 bietet diverse LowPower Modes. Die Modes haben starke Auswirkung auf die Funktionalit\IeC {\"a}t des uControllers w\IeC {\"a}hrend der Schlafphase. Beispielsweise kann um Stop Mode keine UART Schnittstelle benutzt werden. Abh\IeC {\"a}ngig von der ben\IeC {\"o}tigten Peripherie, w\IeC {\"a}hlt der Entwickler einen dieser Modes. Die genutzte Taktfrequenz hat ebenfalls Einfluss auf die Stromaufnahme. Eine Anpassung der Takfrequenz zur Laufzeit ist ebenfalls m\IeC {\"o}glich.}}{10}{figure.16}}
\newlabel{fig:powerconsum}{{16}{10}{Der STM32F4 bietet diverse LowPower Modes. Die Modes haben starke Auswirkung auf die Funktionalität des uControllers während der Schlafphase. Beispielsweise kann um Stop Mode keine UART Schnittstelle benutzt werden. Abhängig von der benötigten Peripherie, wählt der Entwickler einen dieser Modes. Die genutzte Taktfrequenz hat ebenfalls Einfluss auf die Stromaufnahme. Eine Anpassung der Takfrequenz zur Laufzeit ist ebenfalls möglich}{figure.16}{}}
\newlabel{fig:powerconsum@cref}{{[figure][16][]16}{10}}
\newlabel{lst:defineIdleHook}{{2.9}{10}{}{lstlisting.-8}{}}
\newlabel{lst:defineIdleHook@cref}{{[subsection][9][2]2.9}{10}}
\newlabel{lst:xIdleTaskHook}{{6}{10}{Aufruf der IdleTask Hook Funktion durch die FreeRTOS Idle Task. Aus Task.c}{lstlisting.6}{}}
\newlabel{lst:xIdleTaskHook@cref}{{[lstlisting][6][]6}{10}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {6}Aufruf der IdleTask Hook Funktion durch die FreeRTOS Idle Task. Aus Task.c}{10}{lstlisting.6}}
\newlabel{lst:xIdleHookExamp}{{7}{10}{Pseudocode für eine Idle Hook Funktion}{lstlisting.7}{}}
\newlabel{lst:xIdleHookExamp@cref}{{[lstlisting][7][]7}{10}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7}Pseudocode f\IeC {\"u}r eine Idle Hook Funktion}{10}{lstlisting.7}}
\citation{FreeRtosAdvanced}
\citation{9783827373427}
\citation{9783864902222}
\bibstyle{abbrv}
\bibdata{literatur}
\newlabel{lst:defineTicklessIdle}{{2.9}{11}{}{lstlisting.-9}{}}
\newlabel{lst:defineTicklessIdle@cref}{{[subsection][9][2]2.9}{11}}
\@writefile{toc}{\contentsline {section}{\numberline {3}FreeRTOS in der Praxis}{11}{section.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Komplexit\IeC {\"a}t durch Nebenl\IeC {\"a}ufigkeit - Debugging von Echtzeitsystemen}{11}{subsection.3.1}}
\newlabel{sec:Debugging von Echtzeitsystemen}{{3.1}{11}{Komplexität durch Nebenläufigkeit - Debugging von Echtzeitsystemen}{subsection.3.1}{}}
\newlabel{sec:Debugging von Echtzeitsystemen@cref}{{[subsection][1][3]3.1}{11}}
\@writefile{lof}{\contentsline {figure}{\numberline {17}{\ignorespaces In diesem Beispiel ist die IDLE Task running, alle anderen Task blockieren (Hier wird f\IeC {\"u}r den Zustand Blocked die bezeichnung Suspended verwendet). Es kann dennoch durch die Thread Awareness auf den Stacktrace der anderen Task zugegriffen werden }}{11}{figure.17}}
\newlabel{fig:ThreadAware}{{17}{11}{In diesem Beispiel ist die IDLE Task running, alle anderen Task blockieren (Hier wird für den Zustand Blocked die bezeichnung Suspended verwendet). Es kann dennoch durch die Thread Awareness auf den Stacktrace der anderen Task zugegriffen werden}{figure.17}{}}
\newlabel{fig:ThreadAware@cref}{{[figure][17][]17}{11}}
\@writefile{lof}{\contentsline {figure}{\numberline {18}{\ignorespaces Trace Tool Segger Systemview erm\IeC {\"o}glicht die Aufnahme aller Schedulingvorg\IeC {\"a}nge und stellt diese im zeitlichen Verlauf dar. Dem Entwickler ist es somit m\IeC {\"o}glich alle RTOS Operationen r\IeC {\"u}ckblickend zu betrachten.}}{11}{figure.18}}
\newlabel{fig:Systemview}{{18}{11}{Trace Tool Segger Systemview ermöglicht die Aufnahme aller Schedulingvorgänge und stellt diese im zeitlichen Verlauf dar. Dem Entwickler ist es somit möglich alle RTOS Operationen rückblickend zu betrachten}{figure.18}{}}
\newlabel{fig:Systemview@cref}{{[figure][18][]18}{11}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Zusammenfassung}{11}{section.4}}
\bibcite{MasteringFreeRtos}{1}
\bibcite{FreeRtosAdvanced}{2}
\bibcite{9783864902222}{3}
\bibcite{9783827373427}{4}
\bibcite{RTOSRevealed}{5}
\@writefile{lof}{\contentsline {figure}{\numberline {19}{\ignorespaces Die ben\IeC {\"o}tigten Target Files f\IeC {\"u}r die Trace Tools bilden eine weitere Middleware Schicht }}{12}{figure.19}}
\newlabel{fig:SystemviewTarget}{{19}{12}{Die benötigten Target Files für die Trace Tools bilden eine weitere Middleware Schicht}{figure.19}{}}
\newlabel{fig:SystemviewTarget@cref}{{[figure][19][]19}{12}}
