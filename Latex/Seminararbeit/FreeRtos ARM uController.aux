\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\catcode `"\active 
\citation{9780128015070}
\citation{RTOSRevealed}
\citation{RTOSRevealed}
\citation{RTOSRevealed}
\citation{MasteringFreeRtos}
\select@language{ngerman}
\@writefile{toc}{\select@language{ngerman}}
\@writefile{lof}{\select@language{ngerman}}
\@writefile{lot}{\select@language{ngerman}}
\@writefile{toc}{\contentsline {section}{\numberline {1}Grundlagen Echtzeitsysteme}{1}{section.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Echtzeitsysteme und Echtzeitbetriebssysteme}{1}{subsection.1.1}}
\newlabel{sec:Echtzeitsysteme}{{1.1}{1}{Echtzeitsysteme und Echtzeitbetriebssysteme}{subsection.1.1}{}}
\newlabel{sec:Echtzeitsysteme@cref}{{[subsection][1][1]1.1}{1}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces \IeC {\"U}bersicht Programmabl\IeC {\"a}ufe in embedded Anwendungen. Unterscheidung von zwei Hauptkategorien: Schleifen-gesteurte Anwendungen und Event-gesteurte Anwendungen. Bild-Quelle~\citeA {RTOSRevealed}}}{1}{figure.1}}
\newlabel{fig:Programmablauf}{{1}{1}{Übersicht Programmabläufe in embedded Anwendungen. Unterscheidung von zwei Hauptkategorien: Schleifen-gesteurte Anwendungen und Event-gesteurte Anwendungen. Bild-Quelle~\protect \citeA {RTOSRevealed}}{figure.1}{}}
\newlabel{fig:Programmablauf@cref}{{[figure][1][]1}{1}}
\@writefile{lot}{\contentsline {table}{\numberline {1}{\ignorespaces Beispiele von Echtzeitsystemen und deren Auswirkung beim \IeC {\"U}ber- oder Unterschreiten der Anforderungsgrenzen}}{2}{table.1}}
\newlabel{tab:BeispieleEchtzeitsystem}{{1}{2}{Beispiele von Echtzeitsystemen und deren Auswirkung beim Über- oder Unterschreiten der Anforderungsgrenzen}{table.1}{}}
\newlabel{tab:BeispieleEchtzeitsystem@cref}{{[table][1][]1}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {2}FreeRTOS}{2}{section.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Geschichte}{2}{subsection.2.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Entwicklungsumgebung}{2}{subsection.2.2}}
\newlabel{ref:Entwicklungsumgebung}{{2.2}{2}{Entwicklungsumgebung}{subsection.2.2}{}}
\newlabel{ref:Entwicklungsumgebung@cref}{{[subsection][2][2]2.2}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Zielsystem STM32F4 (ARM Cortex M4)}{2}{subsection.2.3}}
\newlabel{sec:Zielsysteme}{{2.3}{2}{Zielsystem STM32F4 (ARM Cortex M4)}{subsection.2.3}{}}
\newlabel{sec:Zielsysteme@cref}{{[subsection][3][2]2.3}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Aufbau der zur Verf\IeC {\"u}gung stehenden STM Bibliotheken }}{3}{figure.2}}
\newlabel{fig:HAL}{{2}{3}{Aufbau der zur Verfügung stehenden STM Bibliotheken}{figure.2}{}}
\newlabel{fig:HAL@cref}{{[figure][2][]2}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Einrichten und Konfiguration}{3}{subsection.2.4}}
\newlabel{sec:Einrichtung und Konfiguration}{{2.4}{3}{Einrichten und Konfiguration}{subsection.2.4}{}}
\newlabel{sec:Einrichtung und Konfiguration@cref}{{[subsection][4][2]2.4}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Erstellung eines Basisprojekts f\IeC {\"u}r den STM32F4 durch das GNU ARM Plugin. Ein Wizard Konfigurator f\IeC {\"u}hrt den Anwender durch alle n\IeC {\"o}tigen Einstellungen. Nach Abschluss erh\IeC {\"a}lt man ein C / C++ ARM Projekt welches passend zum Zielsystem konfiguriert ist.}}{3}{figure.3}}
\newlabel{fig:NewProj}{{3}{3}{Erstellung eines Basisprojekts für den STM32F4 durch das GNU ARM Plugin. Ein Wizard Konfigurator führt den Anwender durch alle nötigen Einstellungen. Nach Abschluss erhält man ein C / C++ ARM Projekt welches passend zum Zielsystem konfiguriert ist}{figure.3}{}}
\newlabel{fig:NewProj@cref}{{[figure][3][]3}{3}}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\citation{FreeRtosAdvanced}
\citation{RTOSRevealed}
\citation{RTOSRevealed}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces ARM embedded Anwendungen setzen auf unterschiedliche Abstraktionsschichten auf. Die untersten beiden Abstraktionsschichten sind CMSIS, welches Funktionen f\IeC {\"u}r ARM Devices bereitstellt, und der HAL des $\mu $Controller Herstellers. CMSIS steht f\IeC {\"u}r alle ARM Systeme zur Verf\IeC {\"u}gung, wohingegen der HAL $\mu $Controller spezifisch ist. }}{4}{figure.4}}
\newlabel{fig:CMSIS}{{4}{4}{ARM embedded Anwendungen setzen auf unterschiedliche Abstraktionsschichten auf. Die untersten beiden Abstraktionsschichten sind CMSIS, welches Funktionen für ARM Devices bereitstellt, und der HAL des $\mu $Controller Herstellers. CMSIS steht für alle ARM Systeme zur Verfügung, wohingegen der HAL $\mu $Controller spezifisch ist}{figure.4}{}}
\newlabel{fig:CMSIS@cref}{{[figure][4][]4}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Die Basiskonfiguration, die durch das GNU ARM Plugin zur Verf\IeC {\"u}gung gestellt wird, besteht aus den Verzeichnissen, Startup, Config und HAL. Startup beinhaltet alle Files zum Starten der Hardware und die main-Funktion. Im Config Verzeichnis befinden sich alle Dateien zur Konfiguration des $\mu $Controllers und die FreeRTOS Config. HAL und CMSIS bilden die Grundlage des Systems und werden ebenfalls durch das GNU ARM Plugin eingef\IeC {\"u}gt. FreeRTOS wird danach manuell dem Projekt hinzugef\IeC {\"u}gt.}}{4}{figure.5}}
\newlabel{fig:SourceTree}{{5}{4}{Die Basiskonfiguration, die durch das GNU ARM Plugin zur Verfügung gestellt wird, besteht aus den Verzeichnissen, Startup, Config und HAL. Startup beinhaltet alle Files zum Starten der Hardware und die main-Funktion. Im Config Verzeichnis befinden sich alle Dateien zur Konfiguration des $\mu $Controllers und die FreeRTOS Config. HAL und CMSIS bilden die Grundlage des Systems und werden ebenfalls durch das GNU ARM Plugin eingefügt. FreeRTOS wird danach manuell dem Projekt hinzugefügt}{figure.5}{}}
\newlabel{fig:SourceTree@cref}{{[figure][5][]5}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.5}Memory Allocation}{4}{subsection.2.5}}
\newlabel{lst:vPortMalloc1}{{2.5}{4}{}{lstlisting.-1}{}}
\newlabel{lst:vPortMalloc1@cref}{{[subsection][5][2]2.5}{4}}
\newlabel{lst:vPortFree1}{{2.5}{4}{}{lstlisting.-2}{}}
\newlabel{lst:vPortFree1@cref}{{[subsection][5][2]2.5}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Einbindung des Speicheralgorithmus Heap1 in Eclipse CDT. Die Algortihmen Heap2 bis Heap5 sind vom Build ausgeschlossen.}}{4}{figure.6}}
\newlabel{fig:HeapsEclipse}{{6}{4}{Einbindung des Speicheralgorithmus Heap1 in Eclipse CDT. Die Algortihmen Heap2 bis Heap5 sind vom Build ausgeschlossen}{figure.6}{}}
\newlabel{fig:HeapsEclipse@cref}{{[figure][6][]6}{4}}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\newlabel{lst:malloc2}{{1}{5}{FreeRTOS Source von pvPortMalloc() aus Heap1.c. Zuerst wird sichergestellt, dass die Startspeicheradresse dem byte-Alignment des $\mu $\-Pro\-zesso\-rs entspricht. Der STM32F4 basiert auf einem 32Bit $\mu $\-Pro\-zesso\-r und hat ein byte-Alignment von 4, sodass die Startadresse immer eine Potenz von 4 sein muss. Danach wird der Scheduler deaktiviert und geprüft, ob genug Speicher zur Verfügung steht. Abschließend wird der Speicher im ucHeap reserviert}{lstlisting.1}{}}
\newlabel{lst:malloc2@cref}{{[lstlisting][1][]1}{5}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {1}FreeRTOS Source von pvPortMalloc() aus Heap1.c. Zuerst wird sichergestellt, dass die Startspeicheradresse dem byte-Alignment des $\mu $\discretionary {-}{}{}Pro\discretionary {-}{}{}zesso\discretionary {-}{}{}rs entspricht. Der STM32F4 basiert auf einem 32Bit $\mu $\discretionary {-}{}{}Pro\discretionary {-}{}{}zesso\discretionary {-}{}{}r und hat ein byte-Alignment von 4, sodass die Startadresse immer eine Potenz von 4 sein muss. Danach wird der Scheduler deaktiviert und gepr\IeC {\"u}ft, ob genug Speicher zur Verf\IeC {\"u}gung steht. Abschlie\IeC {\ss }end wird der Speicher im ucHeap reserviert.}{5}{lstlisting.1}}
\newlabel{lst:free2}{{2}{5}{FreeRTOS Source von vPortFree() aus Heap1.c . Da eine Speicherfreigabe in Heap1 nicht vorgesehen ist, ist diese Funktion leer}{lstlisting.2}{}}
\newlabel{lst:free2@cref}{{[lstlisting][2][]2}{5}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {2}FreeRTOS Source von vPortFree() aus Heap1.c . Da eine Speicherfreigabe in Heap1 nicht vorgesehen ist, ist diese Funktion leer.}{5}{lstlisting.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.5.1}FreeRTOS Algorithmen zur Speicherverwaltung}{5}{subsubsection.2.5.1}}
\newlabel{lst:xTaskCreate}{{3}{5}{FreeRTOS Source von xTaskCreate() aus Task.c. Jeder Task besitzt einen Stack und einen Task Control Block, beide werden beim Aufruf von xTaskCreate (Zeile 2 und Zeile 6) erstellt}{lstlisting.3}{}}
\newlabel{lst:xTaskCreate@cref}{{[lstlisting][3][]3}{5}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {3}FreeRTOS Source von xTaskCreate() aus Task.c. Jeder Task besitzt einen Stack und einen Task Control Block, beide werden beim Aufruf von xTaskCreate (Zeile 2 und Zeile 6) erstellt.}{5}{lstlisting.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Task und Kernel teilen sich in FreeRTOS einen gemeinsamen Adressraum. Dies stellt eine potentielle Fehlerquelle dar. Bild-Quelle~\citeA {RTOSRevealed}}}{5}{figure.7}}
\newlabel{fig:AddressSpace}{{7}{5}{Task und Kernel teilen sich in FreeRTOS einen gemeinsamen Adressraum. Dies stellt eine potentielle Fehlerquelle dar. Bild-Quelle~\protect \citeA {RTOSRevealed}}{figure.7}{}}
\newlabel{fig:AddressSpace@cref}{{[figure][7][]7}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Beispiel Speicherbelegung nach drei Instanziierungen von Tasks durch die Erzeugerfunktion xTaskCreate() unter Verwendung des Speicheralgorithmus Heap1. Bild-Quelle~\citeA {MasteringFreeRtos}}}{5}{figure.8}}
\newlabel{fig:Heap1}{{8}{5}{Beispiel Speicherbelegung nach drei Instanziierungen von Tasks durch die Erzeugerfunktion xTaskCreate() unter Verwendung des Speicheralgorithmus Heap1. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.8}{}}
\newlabel{fig:Heap1@cref}{{[figure][8][]8}{5}}
\citation{RTOSRevealed}
\citation{RTOSRevealed}
\citation{9780128015070}
\citation{LorenK.Rhodes2017}
\citation{LorenK.Rhodes2017}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.5.2}Memory Protection}{6}{subsubsection.2.5.2}}
\newlabel{sec:Memory Protection}{{2.5.2}{6}{Memory Protection}{subsubsection.2.5.2}{}}
\newlabel{sec:Memory Protection@cref}{{[subsubsection][2][2,5]2.5.2}{6}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Zugriffsrechte f\IeC {\"u}r einen Restricted Task werden durch den RTOS Kernel in der MPU konfiguriert. Der Speicherzugriff wird automatisch durch MPU \IeC {\"u}berpr\IeC {\"u}ft und im Fehlerfall an den Kernel gemeldet. Bild-Quelle~\citeA {RTOSRevealed}}}{6}{figure.9}}
\newlabel{fig:AddressSpaceMMU}{{9}{6}{Zugriffsrechte für einen Restricted Task werden durch den RTOS Kernel in der MPU konfiguriert. Der Speicherzugriff wird automatisch durch MPU überprüft und im Fehlerfall an den Kernel gemeldet. Bild-Quelle~\protect \citeA {RTOSRevealed}}{figure.9}{}}
\newlabel{fig:AddressSpaceMMU@cref}{{[figure][9][]9}{6}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.5.3}Static Memory Allocation}{6}{subsubsection.2.5.3}}
\newlabel{lst:staticMemory}{{2.5.3}{6}{}{lstlisting.-4}{}}
\newlabel{lst:staticMemory@cref}{{[subsubsection][3][2,5]2.5.3}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.6}Scheduling}{6}{subsection.2.6}}
\newlabel{Scheduling}{{2.6}{6}{Scheduling}{subsection.2.6}{}}
\newlabel{Scheduling@cref}{{[subsection][6][2]2.6}{6}}
\newlabel{lst:taskPseudo}{{4}{6}{Pseudocode für die Implementierungsmuster eines periodischen (zeitgesteuert) Tasks und sporadischen (eventgesteuert) Tasks ~\protect \citeA {LorenK.Rhodes2017}}{lstlisting.4}{}}
\newlabel{lst:taskPseudo@cref}{{[lstlisting][4][]4}{6}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {4}Pseudocode f\IeC {\"u}r die Implementierungsmuster eines periodischen (zeitgesteuert) Tasks und sporadischen (eventgesteuert) Tasks ~\citeA {LorenK.Rhodes2017}}{6}{lstlisting.4}}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\citation{9783827373427}
\citation{9783827373427}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Der Kontextwechsel eines Tasks findet mitten in der Aus\discretionary {-}{}{}f\IeC {\"u}h\discretionary {-}{}{}rung statt. Alle Register, die f\IeC {\"u}r die weitere Ausf\IeC {\"u}hrung ben\IeC {\"o}tigt werden, werden durch den Scheduler gesichert. Bild-Quelle~\citeA {MasteringFreeRtos} }}{7}{figure.10}}
\newlabel{fig:ContextSwitch}{{10}{7}{Der Kontextwechsel eines Tasks findet mitten in der Aus\-füh\-rung statt. Alle Register, die für die weitere Ausführung benötigt werden, werden durch den Scheduler gesichert. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.10}{}}
\newlabel{fig:ContextSwitch@cref}{{[figure][10][]10}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces \IeC {\"U}bersicht aller Task-Zustandstransitionen in FreeRTOS. Der Zustandswechsel findet entweder durch den Aufruf einer FreeRTOS API Funktion statt oder aber durch Events (z.B. Interrupts, Timer-Events). Der Wechsel in den Zustand Running wird durch den Scheduler bestimmt und ist durch den Schedulingalgorithmus definiert. Bild-Quelle~\citeA {MasteringFreeRtos}}}{7}{figure.11}}
\newlabel{fig:TaskStates}{{11}{7}{Übersicht aller Task-Zustandstransitionen in FreeRTOS. Der Zustandswechsel findet entweder durch den Aufruf einer FreeRTOS API Funktion statt oder aber durch Events (z.B. Interrupts, Timer-Events). Der Wechsel in den Zustand Running wird durch den Scheduler bestimmt und ist durch den Schedulingalgorithmus definiert. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.11}{}}
\newlabel{fig:TaskStates@cref}{{[figure][11][]11}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces Aufbau der Priorit\IeC {\"a}tenliste nach Round Robin in FreeRTOS. Alle aufgef\IeC {\"u}hrten Tasks sind bereit zur Ausf\IeC {\"u}hrung. Task A wird aktuell durch den Scheduler ausgef\IeC {\"u}hrt. Nach dem Ablauf des Zeitquantums wird A hinter B einsortiert. Die Maximale Priorit\IeC {\"a}t wird durch configMaxPrio bestimmt. Der Idle Task wird automatisch durch den Kernel erzeugt und hat immer die niedrigste Priorit\IeC {\"a}t. }}{7}{figure.12}}
\newlabel{fig:PrioList1}{{12}{7}{Aufbau der Prioritätenliste nach Round Robin in FreeRTOS. Alle aufgeführten Tasks sind bereit zur Ausführung. Task A wird aktuell durch den Scheduler ausgeführt. Nach dem Ablauf des Zeitquantums wird A hinter B einsortiert. Die Maximale Priorität wird durch configMaxPrio bestimmt. Der Idle Task wird automatisch durch den Kernel erzeugt und hat immer die niedrigste Priorität}{figure.12}{}}
\newlabel{fig:PrioList1@cref}{{[figure][12][]12}{7}}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\citation{MasteringFreeRtos}
\citation{9780128015070}
\citation{Jones:1997:CRT:269005.266689}
\citation{Regehr:2001:ACR:882481.883779}
\citation{9780128015070}
\citation{9780128015070}
\citation{RealTimePerformance}
\newlabel{lst:nextTask}{{5}{8}{FreeRTOS Source zur Priroty Task Selection aus Task.c. Alle lauffähigen Tasks werden in einem Array verwaltet pxReadyTaskLists. Die Listen verwalten sich durch Referenz-Pointer in den TCBs der einzelnen Tasks}{lstlisting.5}{}}
\newlabel{lst:nextTask@cref}{{[lstlisting][5][]5}{8}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {5}FreeRTOS Source zur Priroty Task Selection aus Task.c. Alle lauff\IeC {\"a}higen Tasks werden in einem Array verwaltet pxReadyTaskLists. Die Listen verwalten sich durch Referenz-Pointer in den TCBs der einzelnen Tasks.}{8}{lstlisting.5}}
\@writefile{lof}{\contentsline {figure}{\numberline {13}{\ignorespaces Im Cooperative Mode wird der Prozessor von einem Task erst abgegeben, wenn dieser explizit taskYield() aufruft. Selbst wenn ein Task mit h\IeC {\"o}herer Priorit\IeC {\"a}t in den Ready Zustand wechselt, l\IeC {\"a}uft der Task mit niedrigerer Priorit\IeC {\"a}t weiter. Im Gegensatz dazu steht das Pre-Emptive Scheduling (hier mit Time-Slicing). Es unterbricht den laufenden Task mit niedrigerer Priorit\IeC {\"a}t sofort, sobald ein Task mit h\IeC {\"o}herer Priorit\IeC {\"a}t in den Zustand Ready wechselt. Bild-Quelle~\citeA {MasteringFreeRtos}}}{8}{figure.13}}
\newlabel{fig:PreVSCo}{{13}{8}{Im Cooperative Mode wird der Prozessor von einem Task erst abgegeben, wenn dieser explizit taskYield() aufruft. Selbst wenn ein Task mit höherer Priorität in den Ready Zustand wechselt, läuft der Task mit niedrigerer Priorität weiter. Im Gegensatz dazu steht das Pre-Emptive Scheduling (hier mit Time-Slicing). Es unterbricht den laufenden Task mit niedrigerer Priorität sofort, sobald ein Task mit höherer Priorität in den Zustand Ready wechselt. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.13}{}}
\newlabel{fig:PreVSCo@cref}{{[figure][13][]13}{8}}
\newlabel{lst:SysTickS}{{6}{8}{FreeRTOS Source des SysTickHandlers aus Task.c. Der SysTickHandler verwaltet den TickCount. Der TickCount dient allen Timingfunktionen des RTOS Kernels als Zeitreferenz. Des Weiteren wird beim aktiven Time Slicing überprüft, ob ein Kontextwechsel nötig ist. Der Kontextwechsel wird dann ggf. durch den PendSVHandler durchgeführt}{lstlisting.6}{}}
\newlabel{lst:SysTickS@cref}{{[lstlisting][6][]6}{8}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {6}FreeRTOS Source des SysTickHandlers aus Task.c. Der SysTickHandler verwaltet den TickCount. Der TickCount dient allen Timingfunktionen des RTOS Kernels als Zeitreferenz. Des Weiteren wird beim aktiven Time Slicing \IeC {\"u}berpr\IeC {\"u}ft, ob ein Kontextwechsel n\IeC {\"o}tig ist. Der Kontextwechsel wird dann ggf. durch den PendSVHandler durchgef\IeC {\"u}hrt.}{8}{lstlisting.6}}
\@writefile{lof}{\contentsline {figure}{\numberline {14}{\ignorespaces Beispielhafter Ablauf eines SysTickInterrupts.(1) kein User Task ist ready, der Idle Task ist aktiv. (2) SysTickInterrupt. (3) SysTickHandler wird aufgerufen. (4) vControlTask ist ready und ein Kontextwechsel wird durchgef\IeC {\"u}hrt. vControlTask hat hier die gleiche Priorit\IeC {\"a}t wie der IdleTask. (5)vControlTask wird ausgef\IeC {\"u}hrt. Bild-Quelle~\citeA {MasteringFreeRtos}}}{8}{figure.14}}
\newlabel{fig:SysTick}{{14}{8}{Beispielhafter Ablauf eines SysTickInterrupts.(1) kein User Task ist ready, der Idle Task ist aktiv. (2) SysTickInterrupt. (3) SysTickHandler wird aufgerufen. (4) vControlTask ist ready und ein Kontextwechsel wird durchgeführt. vControlTask hat hier die gleiche Priorität wie der IdleTask. (5)vControlTask wird ausgeführt. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.14}{}}
\newlabel{fig:SysTick@cref}{{[figure][14][]14}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {15}{\ignorespaces Durch das Zeitschlitzverfahren wechseln sich Task1 und Idle Task bei jedem SysTick Interrupt ab, da beide die gleiche Priorit\IeC {\"a}t haben. Bei T6 ist Task 1 bereit und verdr\IeC {\"a}ngt (preempt) aufgrund seiner h\IeC {\"o}heren Priorit\IeC {\"a}t Task2. Nachdem Task 1 blockiert, wird Task 2 fortgef\IeC {\"u}hrt. Bild-Quelle~\citeA {MasteringFreeRtos}}}{8}{figure.15}}
\newlabel{fig:timeslice}{{15}{8}{Durch das Zeitschlitzverfahren wechseln sich Task1 und Idle Task bei jedem SysTick Interrupt ab, da beide die gleiche Priorität haben. Bei T6 ist Task 1 bereit und verdrängt (preempt) aufgrund seiner höheren Priorität Task2. Nachdem Task 1 blockiert, wird Task 2 fortgeführt. Bild-Quelle~\protect \citeA {MasteringFreeRtos}}{figure.15}{}}
\newlabel{fig:timeslice@cref}{{[figure][15][]15}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.7}Echtzeitf\IeC {\"a}higkeit}{8}{subsection.2.7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.8}Intertask Kommunikation}{9}{subsection.2.8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.9}Interrupt Handling}{10}{subsection.2.9}}
\newlabel{sec:Interrupt}{{2.9}{10}{Interrupt Handling}{subsection.2.9}{}}
\newlabel{sec:Interrupt@cref}{{[subsection][9][2]2.9}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.10}Low Power Modes auf dem STM32F4}{10}{subsection.2.10}}
\newlabel{sec:Low Power Modes}{{2.10}{10}{Low Power Modes auf dem STM32F4}{subsection.2.10}{}}
\newlabel{sec:Low Power Modes@cref}{{[subsection][10][2]2.10}{10}}
\@writefile{lof}{\contentsline {figure}{\numberline {16}{\ignorespaces Der STM32F4 bietet diverse LowPower Modes. Die Modes haben starke Auswirkung auf die Funktionalit\IeC {\"a}t des $\mu $Controllers w\IeC {\"a}hrend der Schlafphase. Beispielsweise kann im Stop Mode keine UART Schnittstelle benutzt werden. Abh\IeC {\"a}ngig von der ben\IeC {\"o}tigten Peripherie, w\IeC {\"a}hlt der Entwickler einen dieser Modes. Die genutzte Taktfrequenz hat ebenfalls Einfluss auf die Stromaufnahme. Eine Anpassung der Takfrequenz zur Laufzeit ist ebenfalls m\IeC {\"o}glich.}}{10}{figure.16}}
\newlabel{fig:powerconsum}{{16}{10}{Der STM32F4 bietet diverse LowPower Modes. Die Modes haben starke Auswirkung auf die Funktionalität des $\mu $Controllers während der Schlafphase. Beispielsweise kann im Stop Mode keine UART Schnittstelle benutzt werden. Abhängig von der benötigten Peripherie, wählt der Entwickler einen dieser Modes. Die genutzte Taktfrequenz hat ebenfalls Einfluss auf die Stromaufnahme. Eine Anpassung der Takfrequenz zur Laufzeit ist ebenfalls möglich}{figure.16}{}}
\newlabel{fig:powerconsum@cref}{{[figure][16][]16}{10}}
\citation{FreeRtosAdvanced}
\citation{9783827373427}
\citation{9783864902222}
\newlabel{lst:defineIdleHook}{{2.10}{11}{}{lstlisting.-11}{}}
\newlabel{lst:defineIdleHook@cref}{{[subsection][10][2]2.10}{11}}
\newlabel{lst:xIdleHookExamp}{{7}{11}{Pseudocode für eine Idle-Hook Funktion}{lstlisting.7}{}}
\newlabel{lst:xIdleHookExamp@cref}{{[lstlisting][7][]7}{11}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7}Pseudocode f\IeC {\"u}r eine Idle-Hook Funktion.}{11}{lstlisting.7}}
\newlabel{lst:defineTicklessIdle}{{2.10}{11}{}{lstlisting.-12}{}}
\newlabel{lst:defineTicklessIdle@cref}{{[subsection][10][2]2.10}{11}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Komplexit\IeC {\"a}t durch Nebenl\IeC {\"a}ufigkeit - Debugging von Echtzeitsystemen}{11}{section.3}}
\newlabel{sec:Debugging von Echtzeitsystemen}{{3}{11}{Komplexität durch Nebenläufigkeit - Debugging von Echtzeitsystemen}{section.3}{}}
\newlabel{sec:Debugging von Echtzeitsystemen@cref}{{[section][3][]3}{11}}
\bibstyle{abbrv}
\bibdata{literatur}
\bibcite{MasteringFreeRtos}{1}
\bibcite{FreeRtosAdvanced}{2}
\bibcite{9780128015070}{3}
\bibcite{9783864902222}{4}
\bibcite{Jones:1997:CRT:269005.266689}{5}
\bibcite{LorenK.Rhodes2017}{6}
\bibcite{Regehr:2001:ACR:882481.883779}{7}
\bibcite{RealTimePerformance}{8}
\bibcite{9783827373427}{9}
\bibcite{RTOSRevealed}{10}
\@writefile{lof}{\contentsline {figure}{\numberline {17}{\ignorespaces In diesem Beispiel ist die IDLE Task running, alle anderen Task blockieren (Hier wird f\IeC {\"u}r den Zustand Blocked die Bezeichnung Suspended verwendet). Es kann jedoch durch die Thread Awareness auf den Stacktrace der anderen Task zugegriffen werden }}{12}{figure.17}}
\newlabel{fig:ThreadAware}{{17}{12}{In diesem Beispiel ist die IDLE Task running, alle anderen Task blockieren (Hier wird für den Zustand Blocked die Bezeichnung Suspended verwendet). Es kann jedoch durch die Thread Awareness auf den Stacktrace der anderen Task zugegriffen werden}{figure.17}{}}
\newlabel{fig:ThreadAware@cref}{{[figure][17][]17}{12}}
\@writefile{lof}{\contentsline {figure}{\numberline {18}{\ignorespaces Trace Tool Segger Systemview erm\IeC {\"o}glicht die Aufnahme aller Schedulingvorg\IeC {\"a}nge und stellt diese im zeitlichen Verlauf dar. Dem Entwickler ist es somit m\IeC {\"o}glich alle RTOS Operationen r\IeC {\"u}ckblickend zu betrachten.}}{12}{figure.18}}
\newlabel{fig:Systemview}{{18}{12}{Trace Tool Segger Systemview ermöglicht die Aufnahme aller Schedulingvorgänge und stellt diese im zeitlichen Verlauf dar. Dem Entwickler ist es somit möglich alle RTOS Operationen rückblickend zu betrachten}{figure.18}{}}
\newlabel{fig:Systemview@cref}{{[figure][18][]18}{12}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Zusammenfassung}{12}{section.4}}
\@writefile{lof}{\contentsline {figure}{\numberline {19}{\ignorespaces Die ben\IeC {\"o}tigten Target Files f\IeC {\"u}r die Trace Tools bilden eine weitere Middleware Schicht.}}{12}{figure.19}}
\newlabel{fig:SystemviewTarget}{{19}{12}{Die benötigten Target Files für die Trace Tools bilden eine weitere Middleware Schicht}{figure.19}{}}
\newlabel{fig:SystemviewTarget@cref}{{[figure][19][]19}{12}}
