%!TEX root = FreeRtos ARM uController.tex
\subsection{Interrupt Handling}
\label{sec:Interrupt}
Interrupts können innerhalb von FreeRTOS auf verschiedenen Wegen behandelt werden. Hierbei bilden durch die Hardware gesteuerte Interrupt Service Routinen (ISR) die Basis. Um die Verarbeitungszeit für einen Interrupt kurz zu halten, führen ISRs gewöhnlich nur wenige Instruktionen aus. Dies geschieht beispielsweise durch das Informieren einer FreeRTOS Task mittels Intertaskkommunikation. Die FreeRTOS Task führt danach die eigentliche Aufgabe aus. Da die normalen API für den Aufruf aus einer Task implementiert wurden und spezielle Eigenschaften einer Task verwenden, kann eine normale API Funktion nicht in einer ISR verwendet werden. Beispielsweise setzen viele Intertask API Funktionen, die Task in den Blocked Zustand. Dies ist im ISR Kontext natürlich nicht möglich.
Damit man diese Funktionen dennoch nutzen kann, stellt FreeRTOS für die meisten Zugriffe auf die API, spezielle ISR API Funktionen zur Verfügung. Diese Funktionen haben den postfix FromISR. ISR API Funktionen deaktivieren kurzfristig die Interruptverarbeitung innerhalb der kritischen Zugriffe.
Damit Tasks die Mög\-lich\-keit haben auf Interrupts zuzugreifen bietet FreeRTOS verschiedene Mög\-lich\-keit\-en an. Zuerst die binären Semaphoren, die mit xSemaphoreCreateBinary(void) erstellt werden. Hierbei handelt es sich um Speichervariablen, die einen binären Wert annehmen können. In dem Moment, in dem die Variable den Wert TRUE annimmt, ändert die Task ihren Zustand von Blocked auf Ready. Die Task kann in den Wartezustand gebracht werden, indem xSemaphoreTake() aufgerufen wird. Die Semaphore selbst wird durch eine ISR gesetzt. Binäre Semaphoren werden meist zu Synchronisationszwecken zwischen einem Task und einem Interrupt eingesetzt.
Da nicht sichergestellt ist, dass die Task innerhalb der Zeitspanne, in der ein weiterer Interrupt auftreten kann, den vorhandenen Interrupt verarbeiteten kann, ist es möglich, dass ein Interrupt bei binären Semaphoren "'verloren'" geht. Abhilfe schaffen hier die Counting Semaphoren. Diese werden durch das Setzen der folgenden Pre-Prozessor Direktive in der FreeRTOS Config aktiviert.
\begin{lstlisting}[numbers = none]
#define configUSE_COUNTING_SEMAPHORES  1
\end{lstlisting}
Im Anschluss kann die Semaphore mittels
\begin{lstlisting}[numbers = none]
xSemaphoreCreateCounting(uxMaxCount,uxInitialCount) 
\end{lstlisting}
angelegt werden. Die Counting Semaphore werden hierbei als Queue angelegt, die jedoch eher wie ein Zähler funktioniert. Der Parameter uxMaxCount legt hierbei fest, ab welchem Wert ein Überlauf des Zählers erfolgt, uxInitialCount legt den Wert des Zählers nach der Initialisierung fest. Im Anschluss können die Counting Semaphoren wie binäre Semaphoren verwendet werden. Der Aufruf von xSemaphoreTake() holt hierbei ein Semaphorenobjekt aus der Queue und versetzt den Task erst in den Blocked Zustand, wenn die Queue leer ist.
Eine Möglichkeit um ganze Gruppen von Interrupts zusammenzufassen, sind die Event Groups. Hierbei geschieht die Tasksteuerung über ganze Bitmasken. Innerhalb einer Task kann eine "unblock condition" definiert werden, die beschreibt, ob der Task nur bei einer vollständig identischen Maske in den Zustand Ready wechselt, oder ob es bereits ausreicht, dass ein einzelnes Bit in der Maske gesetzt wird. Die Bedeutung der einzelnen Bits kann durch die Entwickler frei festgelegt werden. Eine Eventgroup wird mit dem Kommando xEventGroupCreate(void) erzeugt. Mittels xEventGroupSetBits(EventGroup,uxBitsToSet) werden die Bits uxBitsToSet innerhalb der Eventgroup <EventGroup> gesetzt. Diese Funktion kann auch innerhalb von Tasks aufgerufen werden, beispielsweise zum Zwecke der Tasksynchronisation. Eine Task kann sich in den Blocked Zustand versetzen, indem xEventDroupWaitForBits() aufgerufen wird. Diese Funktion erhält außerdem als Parameter die Eventgroup sowie die Bits, die beobachtet werden. Darüber hinaus wird mittels weiterer Parameter festgelegt, ob die aktuell gesetzten Bits zurückgesetzt werden sollen, ob alle Bits für die Reaktivierung des Tasks gesetzt sein müssen, und wie viele Taktzyklen der Task auf die Reaktivierung wartet.
