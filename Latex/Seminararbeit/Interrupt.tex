%!TEX root = FreeRtos ARM uController.tex
\subsection{Interrupt Handling}
\label{sec:Interrupt}
%Michael: Notify hätte hier noch gut reingepasst, das es eine einfache, schnelle und leichtgewichtige Art ist um eine Task aus einer ISR zu informieren.
Interrupts können innerhalb von FreeRTOS auf verschiedenen Wegen behandelt werden. Hierbei bilden die Hardware gesteuerte Interrupt Service Routinen (ISR) die Basis. Um die Verarbeitungszeit für einen Interrupt kurz zu halten, führen ISRs gewöhnlich nur wenige Instruktionen aus. Dies geschieht beispielsweise durch das Informieren einer FreeRTOS Task mittels Intertaskkommunikation. Die FreeRTOS Task führt danach die eigentliche Aufgabe aus. Da die normalen API Funktionen für den Aufruf aus einer Task implementiert wurden und spezielle Eigenschaften einer Task verwenden, kann eine normale API Funktion nicht in einer ISR verwendet werden. Beispielsweise versetzen viele Intertask API Funktionen die aufrufende Task in den Blocked Zustand. Dies ist im ISR Kontext natürlich nicht möglich. Damit man diese Funktionen dennoch nutzen kann, stellt FreeRTOS für die meisten API Funktionen, spezielle ISR API Funktionen zur Verfügung. Diese Funktionen haben den postfix FromISR. ISR API Funktionen deaktivieren kurzfristig die Interruptverarbeitung innerhalb der kritischen Zugriffe.
FreeRTOS bietet verschiedene Mög\-lich\-keit\-en an, um Tasks einen Zugriff auf Interrupts zu ermöglichen.\newline
Zuerst die binären Semaphore, die mit xSemaphoreCreateBinary(void) erstellt werden. Hierbei handelt es sich um Speichervariablen, die einen binären Wert annehmen können. In dem Moment, in dem die Variable den Wert TRUE annimmt, ändert die Task ihren Zustand von Blocked auf Ready. Die Task kann in den Wartezustand gebracht werden, indem xSemaphoreTake() aufgerufen wird. Der Semaphor selbst wird durch eine ISR gesetzt. 
%Was meinst du damit ? Der Semaphor selbst wird durch eine ISR gesetzt. 
Binäre Semaphore werden meist zu Synchronisationszwecken zwischen einem Task und einem Interrupt eingesetzt.
%Michael: Das wurde im Abschnitt vorher eigetlich schon gesagt. Wie gesagt eigentlich dient es zur synchroisierung von Zugriffen auf Ressourcen. 
Da nicht sichergestellt ist, dass die Task innerhalb der Zeitspanne, in der ein weiterer Interrupt auftreten kann, den vorhandenen Interrupt verarbeiteten kann, ist es möglich, dass ein Interrupt bei binären Semaphoren "'verloren'" geht.
%Michael: Das verstehe ich nicht, wie hilft hier ein Counting Semaphor, wenn man einen Interrupt verpasst? Ein counting Semphor würde sich doch auch verzählen. Ein counting semphaor wird doch für ressource genutzt die zählbar sind. z.B. es dürfen nur 5 Teilnehmer auf den Bus zugreifen. 
\newline Abhilfe schaffen hier die Counting Semaphore, die die nächste Zugriffsvariante auf Interrupts darstellen. Die Counting Semaphore werden durch das Setzen der folgenden Pre-Prozessor Direktive in der FreeRTOS Config aktiviert.
\begin{lstlisting}[numbers = none]
#define configUSE_COUNTING_SEMAPHORES  1
\end{lstlisting}
Im Anschluss kann die Semaphore mittels
\begin{lstlisting}[numbers = none]
xSemaphoreCreateCounting(uxMaxCount,uxInitialCount) 
\end{lstlisting}
angelegt werden. Die Counting Semaphore werden hierbei als Queue angelegt, die jedoch eher wie ein Zähler funktionieren. Der Parameter uxMaxCount legt hierbei fest, ab welchem Wert ein Überlauf des Zählers erfolgt. uxInitialCount legt den Wert des Zählers nach der Initialisierung fest. Im Anschluss können die Counting Semaphore wie binäre Semaphore verwendet werden. Der Aufruf von xSemaphoreTake() holt hierbei ein Semaphor-Objekt aus der Queue und versetzt den Task erst in den Blocked Zustand, wenn die Queue leer ist.
Eine Möglichkeit um ganze Gruppen von Interrupts zusammenzufassen sind die Eventgroups. Hierbei geschieht die Tasksteuerung über Bitmasken. Innerhalb eines Tasks kann eine "`unblock condition"' definiert werden. Mit dieser kann definiert werden, ob der Task nur bei einer vollständig identischen Maske in den Zustand Ready wechselt, oder ob es bereits ausreicht, dass ein einzelnes Bit in der Maske gesetzt wird. Die Bedeutung der einzelnen Bits kann durch die Entwickler frei festgelegt werden. Eine Eventgroup wird mit dem Kommando xEventGroupCreate(void) erzeugt. Mittels xEventGroupSetBits(EventGroup,uxBitsToSet) werden die Bits uxBitsToSet innerhalb der Eventgroup gesetzt. Diese Funktion kann auch innerhalb von Tasks aufgerufen werden, beispielsweise zum Zwecke der Tasksynchronisation. Ein Task kann sich in den Blocked Zustand versetzen, indem xEventDroupWaitForBits() aufgerufen wird. Diese Funktion erhält außerdem als Parameter die Eventgroup, sowie die Bits die beobachtet werden. Darüber hinaus wird mittels weiterer Parameter festgelegt, ob die aktuell gesetzten Bits zurückgesetzt werden sollen.
%Michael: von Eventgroups wird laut RealTime Engineers abgeraten siehe : http://www.freertos.org/FreeRTOS-Event-Groups.html und Mastering FreeRTOS Kernal. Vielleicht bekommen die hier etwas viel Aufmerksamkeit :) 
%Als Quellen habe ich hier nur die Beschreibungen aus "`Mastering the FreeRTOS Kernel"' genommen