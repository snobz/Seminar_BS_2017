%!TEX root = FreeRtos ARM uController.tex
\subsection{Interrupt Handling}
Interrupts können innerhalb von FreeRTOS auf verschiedenen Wegen behandelt werden. Hierbei bilden durch die Hardware gesteuerte Interrupt Service Routinen (ISR) die Basis. Die ISR wiederum werden sehr kurz gehalten und führen nur geringfügige Änderungen aus, um die Verarbeitungszeit für einen Interrupt kurz zu halten. Damit im Rahmen von Interrupts keine Störungen im Programmablauf auftreten existieren von vielen Funktionen, welche Werte setzen, Funktionen mit dem postfix FromISR. Diese Funktionen können innerhalb von Interrupts verwendet werden und deaktivieren kurzfristig die Interruptverarbeitung innerhalb der kritischen Zugriffe.
Damit Tasks die Möglichkeit haben auf Interrupts zuzugreifen bietet FreeRTOS verschiedene Möglichkeiten an. Zuerst die binären Semaphoren, die mit xSemaphoreCreateBinary(void) erstellt werden. Hierbei handelt es sich um Speichervariablen, die einen binären Wert annehmen können. In dem Moment, in dem die Variable den Wert TRUE annimmt, ändert die Task ihren Zustand von Blocked auf Ready. Die Task kann in den Wartezustand gebracht werden, indem xSemaphoreTake() aufgerufen wird. Die Semaphore selbst wird durch eine ISR gesetzt. Binäre Semaphoren werden meist zu Synchronisationszwecken zwischen einem Task und einem Interrupt eingesetzt.
Da nicht sichergestellt ist, dass die Task innerhalb der Zeitspanne, in der ein weiterer Interrupt auftreten kann, den vorhandenen Interrupt verarbeiteten kann, ist es möglich, dass ein Interrupt bei binären Semaphoren "'verloren'" geht. Abhilfe schaffen hier die Counting Semaphoren. Diese werden durch das Setzen von configUSE\_COUNTING\_SEMAPHORES auf 1 innerhalb von FreeRTOS.h aktiviert. Im Anschluss kann die Semaphore mittels xSemaphoreCreateCounting(uxMaxCount,uxInitialCount) angelegt werden. Die Counting Semaphoren werden hierbei als Queue angelegt, die jedoch vergleichbar einem Zähler funktioniert. uxMaxCount legt hierbei fest, ab welchem Wert ein Überlauf des Zählers erfolgt, <uxInitialCount> legt den Wert des Zählers nach der Initialisierung fest. Im Anschluss können die Counting Semaphoren wie binäre Semaphoren verwendet werden. Der Aufruf von xSemaphoreTake() holt hierbei ein Semaphorenobjekt aus der Queue und versetzt den Task erst in den Blocked Zustand, wenn die Queue leer ist.
%Deamon Tasks fehlen noch
WIP: Deamon Task
Eine Möglichkeit um ganze Gruppen von Interrupts zu sind die Event Groups. Hierbei geschieht die Tasksteuerung über ganze Bitmasken. Innerhalb einer Task kann eine "unblock condition" definiert werden, die beschreibt, ob der Task nur bei einer vollständig identischen Maske in den Zustand Ready wechselt, oder ob es bereits ausreicht, dass ein einzelnes Bit in der Maske gesetzt wird. Die Bedeutung der einzelnen Bits kann durch die Entwickler frei festgelegt werden. Eine Eventgrout wird mit dem Kommando xEventGroupCreate(void) erzeugt. Mittels xEventGroupSetBits(EventGroup,uxBitsToSet) werden die Bits uxBitsToSet innerhalb der Eventgroup <EventGroup> gesetzt. Diese Funktion kann auch innerhalb von Tasks aufgerufen werden, beispielsweise zum Zwecke der Tasksynchronisation. Eine Task kann sich in den Blocked Zustand versetzen, indem xEventDroupWaitForBits() aufgerufen wird. Diese Funktion erhält außerdem als Parameter die Eventgroup sowie die Bits, die beobachtet werden. Darüber hinaus wird mittels weiterer Parameter festgelegt, ob die aktuell gesetzten Bits zurückgesetzt werden sollen, ob alle Bits für die Reaktivierung des Tasks gesetzt sein müssen, und wie viele Taktzyklen der Task auf die Reaktivierung wartet.
